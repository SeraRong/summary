MySQL 表级锁与行级锁
===========

###1、表级锁
**MySQL 表级锁**分为**读锁**和**写锁**。

####1）读锁
用法：

```
LOCK TABLE table_name [ AS alias_name ] READ
```

- **释放锁**使用 **UNLOCK tables**。

- 可以为**表使用别名**，如果**一旦使用别名**在**使用的时候**也**必须采用别名**。

- 成功**申请读锁的前提**是**当前没有线程对该表使用写锁**，**否则该语句会被阻塞**。

- **申请读锁成功后，其他线程也可以对该表进行读操作，但不允许有线程对其进行写操作，就算是当前线程也不允许。**

- 当**锁住了 A 表**之后，就**只能对 A 表**进行**读操作**，**对其他表进行读操作会出现错误**（tablename was not locked with LOCK TABLES）。

####2）写锁
用法： 

```
LOCK TABLE table_name [AS alias_name] [ LOW_PRIORITY ] WRITE
```

- 同样也**可以使用别名**。

- 与**读锁不同的是**，**写锁中可以指定锁的优先级**。**LOW_PRIORITY** 是一种**比读锁更低优先级的锁**。当**多个线程同时申请多种锁**（LOW_PRIORITY，READ，WRITE）时，**LOW_PRIORITY 的优先级最低**。

- **读锁申请成功的前提**是**没有线程对表加读锁和其他写锁，否则会被阻塞**。

- **表级锁**在 MyISAM 和 innoDB 中都有用到，**创建锁的开销小**，**不会出现死锁**，由于锁定的是整张表，所以**并发度低**。

- 当需要**频繁对大部分数据做 GROUP BY 操作**或者需要**频繁扫描整个表**时，**推荐使用表级锁**。

###2、行级锁
**行级锁**是 **Mysql 中锁定粒度最细的一种锁**，能**大大减少数据库操作的冲突**，由于其**粒度小，加锁的开销最大**。**行级锁**分为**共享锁**和**排他锁**。

####1）共享锁(S LOCK)
用法：

```
SELECT ...LOCK IN SHARE MODE;
```

**Mysql** 会**对查询结果中的每行**都**加共享锁**，当**没有其他线程对查询结果集中的任何一行使用排他锁时**，可以**成功申请共享锁**，**否则会被阻塞**。**其他线程也可以读取使用了共享锁的表**，而且**这些线程读取的是同一个版本的数据**。

####2）排他锁(X LOCK)
用法：

```
SELECT ...LOCK FOR UPDATE;
```

**Mysql** 会**对查询结果中的每行**都**加排他锁**，当**没有其他线程对查询结果集中的任何一行使用排他锁时**，可以**成功申请排他锁**，**否则会被阻塞**。

**行级锁**都是**基于索引的**，如果**一条 SQL 语句用不到索引**是**不会使用行级锁的**，**会使用表级锁**。

**行级锁**的**缺点**是：由于需要**请求大量的锁资源**，所以**速度慢**，**内存消耗大**。
