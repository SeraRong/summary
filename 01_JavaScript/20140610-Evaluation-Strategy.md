JavaScript 赋值策略
=========

在赋值理论里一般有2种**赋值策略**：
- **严格**——意思是说**参数**在进入程序之前是经**过计算过的；**
- **非严格**——意思是**参数**的计算是根**据计算要求才去计算**（也就是相当于延迟计算）。

**【注】**
- 在**ECMAScript**中（甚至其他的语如，C，JAVA，Python和Ruby中）都使用了**严格的参数传递策略**。
- 在**ECMAScript传递参数的计算顺序是左到右**，而且其它语言实现的反省顺序（从右向做）也是可以用的。

###1、按值传递
**按值传递**，**参数的值是**调用者传递的**对象值的拷贝**，**函数内部改变参数的值不会影响到外面的对象**（该参数在外面的值）。一般来说，是**重新分配了新内存**，该新内存块的值是外部对象的拷贝，并且它的值是用到函数内部的。
```
bar = 10
 
procedure foo(barArg):
  barArg = 20;
end
 
foo(bar)
 
// foo内部改变值不会影响内部的bar的值
print(bar) // 10
```
但是，如果该函数的参数不是原始值而是复杂的结构对象，将带来很大的性能问题，C++就有这个问题，将结构作为值传进函数的时候——就是完整的拷贝。

用下面的赋值策略来检验一下。函数接受2个参数，第1个参数是对象的值，第2个是个布尔型的标记，用来标记是否完全修改传入的对象（给对象重新赋值），还是只修改该对象的一些属性。
```
// 注：以下都是伪代码，不是JS实现
bar = {
  x: 10,
  y: 20
}
 
procedure foo(barArg, isFullChange):
 
  if isFullChange:
    barArg = {z: 1, q: 2}
    exit
  end
 
  barArg.x = 100
  barArg.y = 200
 
end
 
foo(bar)
 
// 按值传递，外部的对象不被改变
print(bar) // {x: 10, y: 20}
 
// 完全改变对象（赋新值）
foo(bar, true)
 
//也没有改变
print(bar) // {x: 10, y: 20}, 而不是{z: 1, q: 2}
```

###2、按引用传递
**按引用传递**接收的**不是值拷贝**，而是**对象的隐式引用**，如该对象在外部的直接引用地址。**函数内部对参数的任何改变都是影响该对象在函数外部的值**，因为两者**引用的是同一个对象**，也就是说：这时候参数就相当于外部对象的一个别名。

伪代码：
```
procedure foo(barArg, isFullChange):
 
  if isFullChange:
    barArg = {z: 1, q: 2}
    exit
  end
 
  barArg.x = 100
  barArg.y = 200
 
end
 
// 使用和上例相同的对象
bar = {
  x: 10,
  y: 20
}
 
// 按引用调用的结果如下： 
foo(bar)
 
// 对象的属性值已经被改变了
print(bar) // {x: 100, y: 200}
 
// 重新赋新值也影响到了该对象
foo(bar, true)
 
// 此刻该对象已经是一个新对象了
print(bar) // {z: 1, q: 2}
```
该策略可以更有效地传递复杂对象，例如带有大批量属性的大结构对象。

###3、按共享传递（Call by sharing）
**按共享传递**（“**按对象传递**”或“**按对象共享传递**”）其实是学术上的策略。但是，它在ECMAScript中的参数传递战略中起着关键作用的策略。

**按共享传递**策略的**要点**是：函数接收的是对象对于的拷贝（副本），该引用拷贝和形参以及其值相关联。

这里出现的引用，我们不能称之为“按引用传递”，因为函数接收的参数不是直接的对象别名，而是该引用地址的拷贝。

**【注】**：*函数内部给参数重新赋新值不会影响到外部的对象（和上例按引用传递的case），但是因为该参数是一个地址拷贝，所以在外面访问和里面访问的都是同一个对象（例如外部的该对象不是想按值传递一样完全的拷贝)，改变该参数对象的属性值将会影响到外部的对象。*
```
procedure foo(barArg, isFullChange):
 
  if isFullChange:
    barArg = {z: 1, q: 2}
    exit
  end
 
  barArg.x = 100
  barArg.y = 200
 
end

//还是使用这个对象结构
bar = {
  x: 10,
  y: 20
}
 
// 按贡献传递会影响对象 
foo(bar)
 
// 对象的属性被修改了
print(bar) // {x: 100, y: 200}
 
// 重新赋值没有起作用
foo(bar, true)
 
// 依然是上面的值
print(bar) // {x: 100, y: 200}
```
这个处理的假设前提是大多数语言里用到的对象，而不是原始值。

**【注】** **按共享传递是按值传递的特例。**

###4、按共享与指针
对于С/С+ +，这个策略在思想上和按指针值传递是一样的，但有一个重要的区别：
- 该策略可以取消引用指针以及完全改变对象。
- 在一般情况下，分配一个值（地址）指针到新的内存块（即之前引用的内存块保持不变）；通过指针改变对象属性的话会影响到外部对象。

因此，和指针类别，这是按地址值传递。 在这种情况下，按共享传递只是“语法糖”，像指针赋值行为一样（但不能取消引用），或者像引用一样修改属性（不需要取消引用操作），有时候，它可以被命名为“安全指针”。

然而，С/С+ +如果在没有明显指针的解引用的情况下，引用对象属性的时候，还具有特殊的语法糖：
```
obj->x instead of (*obj).x
```
和C++关系最为紧密的这种意识形态可以从“智能指针”的实现中看到，例如，在 `boost :: shared_ptr`里，重载了赋值操作符以及拷贝构造函数，而且还使用了对象的引用计数器，通过GC删除对象。 这种数据类型，甚至有类似的名字- `共享_ptr`。


##ECMAScript实现
ECMAScript中将对象作为参数传递的策略——按共享传递：修改参数的属性将会影响到外部，而重新赋值将不会影响到外部对象。

```javascript
var foo = {x: 10, y: 20};
var bar = foo;
 
alert(bar === foo); // true
 
bar.x = 100;
bar.y = 200;
 
alert([foo.x, foo.y]); // [100, 200]
```
即两个标识符（名称绑定）绑定到内存中的同一个对象， 共享这个对象：
```
foo value: addr(0xFF) => {x: 100, y: 200} (address 0xFF) <= bar value: addr(0xFF)
```
而重新赋值分配，绑定是新的对象标识符（新地址），而不影响已经先前绑定的对象 ：
```javascript
bar = {z: 1, q: 2};
 
alert([foo.x, foo.y]); // [100, 200] – 没改变
alert([bar.z, bar.q]); // [1, 2] – 但现在引用的是新对象
```

即现在foo和 bar，有不同的值和不同的地址:
```
foo value: addr(0xFF) => {x: 100, y: 200} (address 0xFF)
bar value: addr(0xFA) => {z: 1, q: 2} (address 0xFA)
```

**【注】** 这里所说对象的值是地址（address），而不是对象结构本身，将变量赋值给另外一个变量——是赋值值的引用。因此两个变量引用的是同一个内存地址。下一个赋值却是新地址，是解析与旧对象的地址绑定，然后绑定到新对象的地址上，这就是和按引用传递的最重要区别。
